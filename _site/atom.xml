<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>ySite</title>
   <link href="http://ysite.me/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://ysite.me" rel="alternate" type="text/html" />
   <updated>2014-06-03T22:04:21+08:00</updated>
   <id>http://ysite.me</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>Think in bitwise</title>
     <link href="http://ysite.me/think-in-bitwise"/>
     <updated>2014-06-03T00:00:00+08:00</updated>
     <id>http://beiyuu.com/think-in-bitwise</id>
     <content type="html">&lt;h2&gt;Prerequisite&lt;/h2&gt;

&lt;p&gt;Bitwise operation allows programmers to directly operate number variables in low-level perspective. Types of number could include signed and unsigned integer and float-point number (more on this later). Basically in C, you can use the following operations: left shift and right shift (&amp;lt;&amp;lt; and &gt;&gt;), bitwise and, or, xor, not. Here is an interesting and enlightening passage about bitwise operation, which shocked me a lot when I first read it. But mind yourself, it is written in Chinese.&lt;/p&gt;

&lt;p&gt;OK. If you are familiar with those operations, we can get to the banquet now!&lt;/p&gt;

&lt;p&gt;Oh, sorry. One more thing. Without further instruction, all the problems mentioned below can only be solved using &amp;lt;&amp;lt;, &gt;&gt;, &amp;amp;, |, ~, !, ^, + and any control flow statement (if, switch, for, while, ?: statement, etc) and logic operation (&amp;amp;&amp;amp;, ||, etc) is strictly forbidden. Within these rules, you should reduce the total number of operations as much as possible. This gives us the motivation to keep improving our implementation, and then, the fun of this lab.&lt;/p&gt;

&lt;h2&gt;Appetizer&lt;/h2&gt;

&lt;p&gt;Now I&#39;m gonna show you some higher level usage of bitwise operation by explaning my solutions to the lab problems.&lt;/p&gt;

&lt;h3&gt;isEqual&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/* 
 * isEqual - return 1 if x == y, and 0 otherwise 
 *   Examples: isEqual(5,5) = 1, isEqual(4,5) = 0
 *   Legal ops: ! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;
 *   Max ops: 5
 *   Rating: 2
 */
int isEqual(int x, int y) {
    // To be solved
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quite easy eh. Since we know, one simple way to check if two numbers are identical is to theck the result of xor. Exactly. So we simply return the negation of the xor result. Like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int isEqual(int x, int y) {
    return !(x^y);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This problem is fairly easy, but the idea is important: using xor to check the equivalence of two numbers.&lt;/p&gt;

&lt;h3&gt;byteSwap&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/* 
 * byteSwap - swaps the nth byte and the mth byte
 *  Examples: byteSwap(0x12345678, 1, 3) = 0x56341278
 *            byteSwap(0xDEADBEEF, 0, 2) = 0xDEEFBEAD
 *  You may assume that 0 &amp;lt;= n &amp;lt;= 3, 0 &amp;lt;= m &amp;lt;= 3
 *  Legal ops: ! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;
 *  Max ops: 25
 *  Rating: 2
 */
int byteSwap(int x, int n, int m) {
    // To be solved
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At first glance, it&#39;s easy. But the first few ideas came to my mind involved if statement. Hmm, need to think over it again. Yeah, maybe I could extract the nth byte out into a variable, right shift n bits, left shift m bits and put it into mth byte. The same to mth byte. Great. So here comes the first version of my solution.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int byteSwap(int x, int n, int m) {
    int nl = 0;
    int ml = 0;
    int nb = 0;
    int mb = 0;
    n &amp;lt;&amp;lt;= 3;
    m &amp;lt;&amp;lt;= 3;

    nl = 0xff &amp;lt;&amp;lt; n;
    ml = 0xff &amp;lt;&amp;lt; m;
    nb = x &amp;amp; nl;
    mb = x &amp;amp; ml;

    nb &amp;gt;&amp;gt;= n;
    nb &amp;lt;&amp;lt;= m;
    nb &amp;amp;= ml;
    mb &amp;gt;&amp;gt;= m;
    mb &amp;lt;&amp;lt;= n;
    mb &amp;amp;= nl;

    x &amp;amp;= ~(nl | ml);
    x |= (nb | mb);
    return x;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quite readable and easy to understand. But the total operations reaches 17, while many people can reduce it down to 10. How? After carefully inspecting these codes, I found most operations are wasted in shifting to get the nb and mb to the right location. This could be improved. But, how? If I want to change two bytes, I have to clean the target byte with &amp;amp; and put the byte into it with | (or +). Since no if statement available, the source byte cannot be shift to the target location directly using (n-m or m-n) because I cannot decide wheather to shift left or right. Wait. In &quot;isEqual&quot; problem, we use the property of xor that the result of xor of two identical numbers equals 0. And with another property of xor, commutative law, we can eliminate a number just by xor itself! Great idea.&lt;/p&gt;

&lt;p&gt;So the solution comes out naturally. We first xor the nth byte and mth byte into a new variable. And then shift left to nth byte and xor the original number. Now the nth byte stores the information of mth byte because we xor nth byte twice. Do the same to mth byte and we successfully exchange two bytes!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int byteSwap(int x, int n, int m) {
    int t = 0;
    n &amp;lt;&amp;lt;= 3;
    m &amp;lt;&amp;lt;= 3;

    t = 0xff &amp;amp; ((x&amp;gt;&amp;gt;n) ^ (x&amp;gt;&amp;gt;m));

    x ^= t&amp;lt;&amp;lt;n;
    x ^= t&amp;lt;&amp;lt;m;

    return x;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Magic xor operation. So another tricky usage of xor. Now, things get more fun.&lt;/p&gt;

&lt;h3&gt;sign&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/* 
 * sign - return 1 if positive, 0 if zero, and -1 if negative
 *  Examples: sign(130) = 1
 *            sign(-23) = -1
 *  Legal ops: ! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;
 *  Max ops: 10
 *  Rating: 2
 */
int sign(int x) {
    // To be solved
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In 2&#39;s complement, the most significant bit defines it to be a negative (1) or a non-negative (0) number. But it cannot distinguish positive numbers from 0. On the other hand, if we use ! operation, we could distinguish 0 from non-zero numbers, but not positive from negative. So we could combine these two operations and get the answer. One thing to be noted, right shifting an int variable x will result in 0 (when x is non-negative) or -1 (when x is negative; -1 == 0xFFFFFFFF, right shift signed number will automatically fill the sign bit). Here comes the code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int sign(int x) {
    return ((!x)^1) | (x&amp;gt;&amp;gt;31);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Main course&lt;/h2&gt;

&lt;p&gt;OK. We have seen some easy problems and know how to think in bitwise operation. Now we are taking some real challenges.&lt;/p&gt;

&lt;h3&gt;logicalNeg&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/* 
 * logicalNeg - implement the ! operator using any of 
 *              the legal operators except !
 *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1
 *   Legal ops: ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;
 *   Max ops: 12
 *   Rating: 4 
 */
 int logicalNeg(int x) {
    // To be solved
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To make it more bitwise way, this function should return 0 if in argument has any 1 in any bit, otherwise return 1. In this case, the most obvious way is to or every bit and return the result. Unfortunately, it exceeds the maximun op. But it is a right way. Now that we cannot test only 1 bit at one time, we may test more bits at one time. Half is a good idea.&lt;/p&gt;

&lt;p&gt;First, we let the high 16 bits or to low 16 bits of x. Now all the 1(s) in x (if any) comes to low 16 bits of x. And then, let the second byte from the least significant byte or to the least significant byte. All the 1(s) in x (if any) comes to least significant byte. Repeat this process until all the 1s comes to the least significant bit. Now we just need to return the negation of that bit. But the number of operations reaches 12, the maximum limitation. Seems that we need to change a way to think.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int logicalNeg(int x) {
    x |= (x&amp;gt;&amp;gt;16);
    x |= (x&amp;gt;&amp;gt;8);
    x |= (x&amp;gt;&amp;gt;4);
    x |= (x&amp;gt;&amp;gt;2);
    x |= (x&amp;gt;&amp;gt;1);
    x = ~x;
    return x &amp;amp; 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Think deeper, and you will find that the key of this problem lies in distinguishing 0 from non-zero numbers. In bitwise world, 0 is unique because the 2&#39;s complement of 0 equals 0 itself, while other numbers are not. But if we solely take advantage of this, we will come back to the awkward situation where we need to find if a number is 0. We should go further.&lt;/p&gt;

&lt;p&gt;Transforming a 32-bit number into a 1-bit number mostly depends on one bit (usually either the MSB or the LSB). And the only one bit in a number that is predicable is sign bit (MSB). Think about this. The sign bit of the 2&#39;s complement and the origin of a non-zero number must be different. While 0 is the same (both 0). So we can take advantage of this and solve the problem within 6 operations.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int logicalNeg(int x) {
    x = ((~x) &amp;amp; (~(~x+1)))&amp;gt;&amp;gt;31;
    return x &amp;amp; 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;howManyBits&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/* howManyBits - return the minimum number of bits required to represent x in
 *             two&#39;s complement
 *  Examples: howManyBits(12) = 5
 *            howManyBits(298) = 10
 *            howManyBits(-5) = 4
 *            howManyBits(0)  = 1
 *            howManyBits(-1) = 1
 *            howManyBits(0x80000000) = 32
 *  Legal ops: ! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;
 *  Max ops: 90
 *  Rating: 4
 */
int howManyBits(int x) {
    // To be solved
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally here comes the real boss. Look at the max op. It&#39;s 90! It is a long story optimizing this function. I will finish it later.&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>My final CPC: memorial to SYSUCPC 14'</title>
     <link href="http://ysite.me/memorial-to-the-sysucpc14"/>
     <updated>2014-04-12T00:00:00+08:00</updated>
     <id>http://beiyuu.com/memorial-to-the-sysucpc14</id>
     <content type="html">&lt;h2&gt;Our team&lt;/h2&gt;

&lt;p&gt;My teammates are &lt;a href=&quot;http://blog.t-xx.me/&quot;&gt;txx&lt;/a&gt; and &lt;a href=&quot;http://www.ghost233.me/&quot;&gt;Ghost&lt;/a&gt;. Actually, we teamed up when we were freshmen to participate in the SYSUCPC 11&#39;. But at that time we were kind of arrogant because three of us started programming before entering university and they two even didn&#39;t take the GaoKao (winning the first prize in the NOIP will grant you an admission to almost any university in China). The arrogance kicked us and we didn&#39;t win the first prize and hence the entrance to the GDCPC 11&#39;.&lt;/p&gt;

&lt;p&gt;If you read the About Me page carefully, you will know that txx and Ghost are also my team members in Martin Network. Indeed, we are an effective team.&lt;/p&gt;

&lt;h2&gt;Why we participate in SYSUCPC in our senior year?&lt;/h2&gt;

&lt;p&gt;During the registration, we can hardly see teams consist of senior students. Many senior students are engaged in the internship or travelling. But three of us are relatively free this time. Txx is now a technical director in an steadily-developing start-up. Ghost left Flamingo and is now looking for a new employer. As for me, I&#39;m living the most comfortable life among classmates after I accepted the admission from CMU.&lt;/p&gt;

&lt;p&gt;Besides, we think this is the last time we can participate in a CPC. So we don&#39;t want to waste the chance to memorize the time when we were fighting in an programming contest. All of us started participating in such contest at least in ninth grade. So it means much in our lives.&lt;/p&gt;

&lt;h2&gt;Online preliminary contest&lt;/h2&gt;

&lt;p&gt;The number of teams registered for SYSUCPC 14&#39; exceeded 150, the maximun capacity of the computer room. So there has to be a preliminary contest to select 150 teams to take the formal SYSUCPC 14&#39;. This contest was held at &lt;a href=&quot;http://soj.me/&quot;&gt;Sicily&lt;/a&gt;, the online judge system of SYSU.&lt;/p&gt;

&lt;p&gt;At that night of the contest, Ghost was sick and given a drip in hospital. Txx was still in Beijing, meeting clients of the start-up. So I had to solve the problems on my own. Haven&#39;t coded for about one year, I was a little bit nervous. But several years&#39; programming experience made me solve the first two easy problems quickly. After gaining some confidence, I started to solve the third problem. I knew how to solve, but it was just a little tricky. I coded for about an hour and finally it was accepted after two submissions.&lt;/p&gt;

&lt;p&gt;Realizing that not much time left and we were at a good ranking, I stopped writing and started to chat with txx and Ghost. They were discussing how another problem could possibly be solved. And I occasionally expressed my opinions and joked. Anyway, this contest is more a warm-up than a contest for us.&lt;/p&gt;

&lt;h2&gt;First round contest&lt;/h2&gt;

&lt;p&gt;Not like before, SYSUCPC 14&#39; consists of two separate contests. Top 40 teams will be authorized to take the second one. The second contest is Guangdong VS Zhejiang CPC. There&#39;re ten teams from ten universities respectively from Guangdong and Zhejiang, five from GD and five from ZJ. Other selected teams would take the synchronous contest, which means we solve the problems at the same time with those 10 teams, but we share different rankings.&lt;/p&gt;

&lt;p&gt;So the goal of the first contest would be ranking top 40. At first we were not confident about that because three of us hadn&#39;t trained for more than one year, but after careful analysis, we thought we have great chance. And it turned out to be right.&lt;/p&gt;

&lt;p&gt;In the first hour we solved three easy problems. After that, txx was coding on a simple but tricky problem. And I was working on a pure dynamic programming problem. but with extremely large scale input data (10&lt;sup&gt;9&lt;/sup&gt;). An algorithm with O(n) time complexity would result in TLE. So we had to either think of a mathematical method to simplify it, or reduce the complexity to O(lgn).&lt;/p&gt;

&lt;p&gt;When I was struggling, txx&#39;s program was accepted and only one hour was left. At that time, we ranked 30+ and was at the fringe entering second round. Before that, I was trying mathematical methods, but failed. So I turned to state transition function. After several tries, I successfully divided the sub-problem in a half scale. So the overall complexity became O(lgn). I was so excited and went to code.&lt;/p&gt;

&lt;p&gt;The first time I submitted my code, I got WA. Would that be caused by a wrong state transition function? I checked the function carefully and assured the righteousness of it. Curious enough, I read my code one line by another. And I found that I wrote &quot;a * b;&quot; instead of &quot;a *= b;&quot; by mistake. What an idiot. After correcting this, I submitted again and got Accepted. At that time only 20 minutes left.&lt;/p&gt;

&lt;p&gt;Finally in the first round, we ranked 16, which surprised us a lot. And we had a great dinner in an Mexican Restaurant. BTW, there are almost all foreigners in that restaurant. Txx and Ghost said the food was delicious, but I tasted bland because I got a cold that day. After the dinner I felt even worse. I went back to dormitory quickly, took a shower and went to sleep early.&lt;/p&gt;

&lt;h2&gt;Second round contest&lt;/h2&gt;

&lt;p&gt;Thanks to the antibiotic, I was feeling well at the day of second round contest. With the good ranking in the first round, we were confident about ourselves.&lt;/p&gt;

&lt;p&gt;Five minutes after the contest began, more and more teams solved the first problem. It was a game theory problem and we couldn&#39;t find a way to solve it. With simple test, we guessed that if the size is larger than 3, the first player wins, otherwise the second. Apparently it was wrong. But almost all teams solved that problem, we thought it must be very simple. So we guessed that when the size is even, the first player wins, otherwise the second. Surprisingly but not unexpectedly, it was accepted. So we quickly moved on to the next problem.&lt;/p&gt;

&lt;p&gt;The second is a greedy algorithm. After several discussions, I began coding. The first submission got TLE because I set a three-dimensional array with a 3-level nested loop rather than memset() function. After I using memset(), it was accepted. So far so good.&lt;/p&gt;

&lt;p&gt;However, our tragedy began. Txx and I was think about a mathematical problem, which many teams solved, while Ghost was coding on a simple but very tricky problem. Three hours passed, and neither of us made it through. It seemed that the mathematical problem could be solved, but the idea slipped away every time I tried to catch it. Ghost always had a bad reputation on his correctness of coding. This time was no exception. WA, WA and WA. Finally we only solved two problems.&lt;/p&gt;

&lt;p&gt;After the contest, we went to MingChu in Jiangnan Xi for dinner. The curry there catches me every time. At dinner, we talked about the Sui Bian in RBT. Ghost recommended it but both txx and I hadn&#39;t tasted. So we gave it a try after the dinner. Still not satisfied, we went to Mr. X to play Penetralium Escaping. Maybe we were disappointed about our performance in the contest, we played hard to escape from penetralium. In the end, we managed to escape right before the time ran out. Not a bad day ha.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/memorial_to_sysucpc14/p1.jpg&quot;&gt;&lt;/p&gt;

&lt;h2&gt;Prostscript&lt;/h2&gt;

&lt;p&gt;Txx said after the second round contest, &#39;never let Ghost debug more than 1 hour next time&#39;. Aha indeed. But this is the last time. Where is next time?&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>Change the look of my blog</title>
     <link href="http://ysite.me/change-the-look-of-my-blog"/>
     <updated>2014-04-09T12:05:20Z</updated>
     <id>http://beiyuu.com/change-the-look-of-my-blog</id>
     <content type="html">&lt;p&gt;The default theme of Jekyll is too simple and looks not very well. After careful search, I found &lt;a href=&quot;http://jekyllbootstrap.com/&quot;&gt;Jekyll Bootstrap&lt;/a&gt; might be a good way to construct my own blog. But the themes JB provides didn&#39;t satisfy me. Plus, I know little about front-end and can almost do nothing to change the way it looks like. So I decide to use the style of &lt;a href=&quot;http://beiyuu.com/&quot;&gt;BeiYuu&lt;/a&gt;. Thank BeiYuu for his generous open source of his own blog.&lt;/p&gt;

&lt;p&gt;When constructing this new blog, I learnt so much about the front-end. Without the help of &lt;a href=&quot;https://typeof.us/&quot;&gt;rex&lt;/a&gt;, I would not accomplish this. Many thanks to rex, my dear roommate.&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>Switch to GitHub Pages + Jekyll!</title>
     <link href="http://ysite.me/my-new-blog"/>
     <updated>2014-03-03T19:37:20Z</updated>
     <id>http://beiyuu.com/my-new-blog</id>
     <content type="html">&lt;p&gt;After months&#39; delay, I finally continue to write the blog. Due to the shortage of money, I cannot afford an VPS, even if I share the rent with a friend. On the other hand, WordPress is a little bit clumsy for me. So I switch to the GitHub Pages. All the posts are safely stored on GitHub and I have no need to worry about the backup when VPS expires. Besides, the style is so simple and neat, which perfectly satisfies me. Everything looks great here.&lt;/p&gt;

&lt;p&gt;I will find some valuable posts on my earlier blog and post here. Hope I can keep the blog rate at one post per week. Kill the procrastination!&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>Write your own linux shell</title>
     <link href="http://ysite.me/write-your-own-linux-shell"/>
     <updated>2012-06-30T00:00:00+08:00</updated>
     <id>http://beiyuu.com/write-your-own-linux-shell</id>
     <content type="html">&lt;h2&gt;什么是shell&lt;/h2&gt;

&lt;p&gt;shell是提供操作系统内核级服务的一个用户调度接口，一般分为两种：命令行接口（Command-Line Interface, CLI）和图形化接口（Graphical User Interface, GUI）。对于我们常用的Windows系统来说，大家一般接触的最多的是GUI。使用鼠标指指点点就可以完成大部分的工作。然而在GUI出现之前，shell就是CLI的天下，即便是到了今天windows统治了PC大部分的市场，CLI的shell依然有他不可替代的优势——更加底层、更加接近问题的中心。&lt;/p&gt;

&lt;p&gt;CMD命令行可以认为是Windows下的CLI shell，而在Unix/Linux下，其CLI shell通常被叫做terminal。在terminal里面，我们就需要通过输入各种命令来完成平常鼠标指指点点完成的操作，例如新建文件夹，重命名文件等。&lt;/p&gt;

&lt;p&gt;既然shell是一个介于用户和系统内核之间的一个程序，那只要知道了如何调用一些系统函数，我们就可以实现一个我们自己的shell。由于linux开源的特性，我们可以很便捷的查到linux提供的系统级函数，实现也比较方便。事实上，linux下可供选择的shell也比较多，一般我们常用的shell是&lt;a href=&quot;http://en.wikipedia.org/wiki/Stephen_R._Bourne&quot;&gt;Steven Bourne&lt;/a&gt;编写的&lt;a href=&quot;https://www.gnu.org/software/bash/&quot;&gt;BASH&lt;/a&gt;（GNU Bourne-Again Shell）。而在windows下，由于其源代码并未开放，要为其实现一个完整功能的shell比较困难，但是我们仍然可以利用现有能够调用的函数来实现一个简单的shell。&lt;/p&gt;

&lt;h2&gt;实现shell的基本原理&lt;/h2&gt;

&lt;p&gt;前面我们说到shell主要的功能就是把系统函数封装一遍提供给用户调用。那么shell的基本工作流程就比较清楚了：接收用户输入-&gt;分析其命令-&gt;调用系统函数-&gt;输出运行结果。&lt;/p&gt;

&lt;p&gt;这里我们主要分析调用系统函数这部分，以linux为例进行分析。我们知道linux是一个开源的系统，所有人都可以修改其源代码，或者为其添加小工具。所以在linux下，最基本的功能都是一个个独立的小程序，由不同的人编写。例如我们使用率极高的ls、cp、mv等命令，都是对应一个程序，放在系统环境目录下。当我们输入ls时，系统会在环境目录下面去寻找ls这个程序来运行。所以在编写linux的shell时，我们就可以直接调用这些小程序。&lt;/p&gt;

&lt;p&gt;而除了这些系统命令，shell还应该实现一些内置的命令，例如使用的最频繁的cd命令。这个命令不是系统命令，在PATH路径下是无法找到此程序的，他的实现是在shell内部实现的。所以我们需要在我们的shell的代码里面单独判断这些内置命令进行实现。&lt;/p&gt;

&lt;p&gt;综上所述，我们可以得到一个shell的主要工作流程如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/write_your_own_linux_shell/p1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;【shell程序主要流程】&lt;/p&gt;

&lt;h2&gt;linux下shell的具体实现&lt;/h2&gt;

&lt;h3&gt;词法分析&lt;/h3&gt;

&lt;p&gt;在获取到了用户输入的命令后的第一步，就是要对指令进行分解和解析。对指令的分析，实际上是对词法分析的过程。在编译原理里面，&lt;a href=&quot;http://dinosaur.compilertools.net/lex/&quot;&gt;lex&lt;/a&gt;和&lt;a href=&quot;http://dinosaur.compilertools.net/yacc/&quot;&gt;yacc&lt;/a&gt;是两个非常有名的词法解析工具。两者都有GNU的版本，分别叫做&lt;a href=&quot;http://dinosaur.compilertools.net/flex/&quot;&gt;flex&lt;/a&gt;和&lt;a href=&quot;http://dinosaur.compilertools.net/bison/&quot;&gt;bison&lt;/a&gt;。使用这两者来替代我们的词法分析工作是非常惬意的事，毕竟这是拿来写编译器的利器，用来应付我们这简单的shell完全不在话下。而且在BASH里面的确也是用到了词法分析和yacc这两个工具。&lt;/p&gt;

&lt;p&gt;但是杀鸡焉用宰牛刀，我们只是想要实现一个简单的shell，并无过多的要求，而且lex的学习成本非常之高，要熟练使用需要很长的学习时间。所以我们这里就简单使用字符串处理来完成词法分析。&lt;/p&gt;

&lt;p&gt;我们这里的词法分析主要任务是把输入的指令分解出命令和参数，然后判断是不是shell内部命令，如果是则进行特殊处理。否则就把命令和参数传给exec函数族进行小工具调用。其中还涉及到管道的“|”、重定向的“&amp;lt;”和“&gt;”、后台程序的“&amp;amp;”和指令结束的“;”等特殊符号的处理。由于是手工处理词法分析，引号的处理就把它暂时忽略了，如果加上引号处理的话就会使代码变得非常臃肿，而且引号在shell命令中出现的频率非常之低。支持引号带来的“性价比”并不高。&lt;/p&gt;

&lt;p&gt;词法分析的代码我们并没有单独做成一个模块，而是把他们融合在代码执行的过程中，这样虽然耦合性较高，但是使用起来较为方便。而且如果需要解耦的话，我们完全可以使用上面说到的flex来实现。&lt;/p&gt;

&lt;h3&gt;shell内置命令的实现&lt;/h3&gt;

&lt;p&gt;前面说到cd和exit等命令是属于shell的内部命令，也即在PATH路径下是找不到相关的程序的（你可以尝试到你的linux的PATH目录下去搜索一下cd）。所以这一些特殊的命令是需要我们单独在shell里面实现的。在我们的shell里面我们内置了如下几个命令：cd（改变工作目录）、about（显示个性化说明信息）、exit（离开shell）。&lt;/p&gt;

&lt;p&gt;这几个命令的实现都不难，cd可以调用chdir()函数（在&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/7908799/xsh/unistd.h.html&quot;&gt;unistd.h&lt;/a&gt;里）进行工作目录的切换，注意一下返回值的错误判断即可。about和exit命令就更加简单，about就输出一段说明文字即可，exit退出还需要注意各种内存的释放，不要忘记free掉malloc得到的空间造成内存泄漏。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/write_your_own_linux_shell/p2.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;【图2】cd命令的实现&lt;/p&gt;

&lt;h3&gt;linux命令的实现&lt;/h3&gt;

&lt;p&gt;如之前所述，linux内置程序命令的执行是直接调用PAHT路径下的程序来运行实现的。我们可以使用exec函数族（在unistd.h中）函数来进行调用。只需要把命令和参数分别传给这个函数，他就会自动在PATH目录下搜索相应的程序并且运行。但是这个函数族有一个缺点，就是他会替代掉我们这个进程的上下文，导致那个小程序运行完后整个程序就运行完了。直观点看这个问题就是，我在shell里面输入ls，当前目录下的文件显示出来之后整个shell就关闭了。这显然是不符合shell的要求的。&lt;/p&gt;

&lt;p&gt;这样我们就要利用到linux下的一个神级系统函数&lt;a href=&quot;http://man7.org/linux/man-pages/man2/fork.2.html&quot;&gt;fork()&lt;/a&gt;函数，他的功能是创建一个子进程，并且把当前程序的上下文环境复制到子进程里面。利用这个函数，我们在要调用一个命令时，先开一个子进程，在子进程里面调用exec函数族的函数，这样调用结束后结束的是子进程，并不会干扰到我们的shell父进程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/write_your_own_linux_shell/p3.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;【图3】linux命令处理流程&lt;/p&gt;

&lt;p&gt;还有一个需要注意的地方，在调用了exec进行系统函数调用之后，用户可以对程序发送一系列信号。例如按住CTRL+C来中止当前程序的运行，这对程序来说是非正常结束，返回值不为0，需要捕获一下以备以后来进行处理。还有，当在shell内等待输入的时候捕获到了CTRL+C的中止信号，shell不应该被直接结束，按照BASH的风格是不做处理。所以我们也对程序进行一个&lt;a href=&quot;http://en.wikipedia.org/wiki/SIGINT_(POSIX)#SIGINT&quot;&gt;SIGINT&lt;/a&gt;信号的捕获，捕获之后不做任何事。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/write_your_own_linux_shell/p3.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;【图4】中止信号响应函数&lt;/p&gt;

&lt;h2&gt;管道、流重定向以及后台运行的实现&lt;/h2&gt;

&lt;p&gt;在BASH里面，可以使用“|”符号进行管道操作，即把此符号之前的命令的输出作为之后的命令的输入。还可以使用流重定向符“&amp;lt;”和“&gt;”把输入或者输出流进行重定向到文件里面。还支持“&amp;amp;”让程序后台运行。我们自己的shell也需要实现这两个功能。&lt;/p&gt;

&lt;p&gt;代码中通过pipe()函数来创建管道，创建之后父进程和子进程一个只能向管道写内容，一个只能向管道读内容。然后利用dup2()函数来把进程的输入流或者输出流重定向到管道里，这样就能实现管道的操作。实现的时候注意可以使用多个“|”来迭代进行管道操作，需要使用一个循环来处理。同时还要注意最后一个操作的输出流是标准输出（即屏幕），不需要重定向到管道里，需要特殊处理一下。&lt;/p&gt;

&lt;p&gt;流重定向的处理比较简单，可以在一开始的时候就定义文件符，并且默认指向标准输入输出流。然后判断命令里是否存在流重定向符，如果存在则将文件符指向相应的文件。如此便可以使用文件输入输出统一输入输出方式，操作比较方便。&lt;/p&gt;

&lt;p&gt;后台运行的处理方式更加简便，开始时先判断是否存在“&amp;amp;”字符，如果存在就把“&amp;amp;”在命令里删除并且把标识符置1，否则置0。然后父进程里面直接判断标识符，如果为1则不需等待子进程，否则就等待子进程即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/write_your_own_linux_shell/p3.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;【图5】主函数中调用相应的操作&lt;/p&gt;

&lt;h2&gt;可以改进的地方&lt;/h2&gt;

&lt;p&gt;Linux版的shell基本实现BASH的大部分功能，但还是有小部分没有完全实现。例如上下箭头的历史记录以及TAB自动补全的支持。这个可以使用&lt;a href=&quot;http://cnswww.cns.cwru.edu/php/chet/readline/rltop.html&quot;&gt;readline&lt;/a&gt;库来实现。还有就是上面提到的对于引号的支持，这个我暂时还没有花时间去思考，不过应该不难实现。
另外，在编写的过程中发现了&lt;a href=&quot;http://book.douban.com/subject/1788421/&quot;&gt;《UNIX环境高级编程》&lt;/a&gt;这本神书，非常推荐看。&lt;/p&gt;
</content>
   </entry>
   
 
</feed>
